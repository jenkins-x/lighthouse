# Package k8s.io/apimachinery/pkg/api/resource

- [Quantity](#Quantity)


## Quantity

Quantity is a fixed-point representation of a number.<br />It provides convenient marshaling/unmarshaling in JSON and YAML,<br />in addition to String() and AsInt64() accessors.<br /><br />The serialization format is:<br /><br /><quantity>        ::= <signedNumber><suffix><br />  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)<br /><digit>           ::= 0 | 1 | ... | 9<br /><digits>          ::= <digit> | <digit><digits><br /><number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits><br /><sign>            ::= "+" | "-"<br /><signedNumber>    ::= <number> | <sign><number><br /><suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI><br /><binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei<br />  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)<br /><decimalSI>       ::= m | "" | k | M | G | T | P | E<br />  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)<br /><decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber><br /><br />No matter which of the three exponent forms is used, no quantity may represent<br />a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal<br />places. Numbers larger or more precise will be capped or rounded up.<br />(E.g.: 0.1m will rounded up to 1m.)<br />This may be extended in the future if we require larger or smaller quantities.<br /><br />When a Quantity is parsed from a string, it will remember the type of suffix<br />it had, and will use the same type again when it is serialized.<br /><br />Before serializing, Quantity will be put in "canonical form".<br />This means that Exponent/suffix will be adjusted up or down (with a<br />corresponding increase or decrease in Mantissa) such that:<br />  a. No precision is lost<br />  b. No fractional digits will be emitted<br />  c. The exponent (or suffix) is as large as possible.<br />The sign will be omitted unless the number is negative.<br /><br />Examples:<br />  1.5 will be serialized as "1500m"<br />  1.5Gi will be serialized as "1536Mi"<br /><br />Note that the quantity will NEVER be internally represented by a<br />floating point number. That is the whole point of this exercise.<br /><br />Non-canonical values will still parse as long as they are well formed,<br />but will be re-emitted in their canonical form. (So always use canonical<br />form, or don't diff.)<br /><br />This format is intended to make it difficult to use these numbers without<br />writing some sort of special handling code in the hopes that that will<br />cause implementors to also use a fixed point implementation.<br /><br />+protobuf=true<br />+protobuf.embed=string<br />+protobuf.options.marshal=false<br />+protobuf.options.(gogoproto.goproto_stringer)=false<br />+k8s:deepcopy-gen=true<br />+k8s:openapi-gen=true




